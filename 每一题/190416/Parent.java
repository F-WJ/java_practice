package title02;

public class Parent {
    private void fun1(){}
    void fun2(){}
    protected void fun3(){}
    public static void fun4(){}
}

/*
选择正确
A.Parent的子类一定能够继承和覆盖fun1方法
B.Parent的子类一定能够继承和覆盖fun2方法
C.Parent的子类一定能够继承和覆盖fun3方法
D.Parent的子类一定能够继承和覆盖fun4方法

答案与解析
1.相关知识子类继承父类后，可以对父类的方法进行覆盖
当方法被覆盖后，调用子类实例的同名方法时会优先调用覆盖的方法，不会再调用父类的方法。
当子类未拥有父类相应方法的访问权限时无法对同名方法进行重写，而是重新定义。
2.答案解析
A.fun1方法为私有权限，无法被子类继承，因此无法被重写
B.fun2方法为包权限，因此在同一个包内继承时，可以重写，但其他包继承无法重写
C.fun3方法为子类访问权限，因此无论如何继承，都可以被重写。
D.fun4方法虽然是公有的访问权限，但为静态方法，无法被继承，并且子类无法定义同名方法。
因此，答案选C。

注意:
无论是static修饰的变量，还是static修饰的方法，我们都知道他们是属于类本身的，
不是属于某一个对象的，当声明一个对象时，并不产生static变量和方法的拷贝。
也就是说，用static修饰的变量和方法在类加载的时候，只分配一块存储空间，所有此类的对象都可以操控此块存储空间；
这里要说明的时，当子类没有与之同名的static变量（或方法时），
子类的对象也可以操控这块内存空间。但是子类并没有继承父类中static修饰的变量和方法。
因为static修饰的变量和方法是属于父类本身的。

1）子类是不继承父类的static变量和方法的。因为这是属于类本身的。但是子类是可以访问的。
2）子类和父类中同名的static变量和方法都是相互独立的，并不存在任何的重写的关系。
*/